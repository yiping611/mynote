<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>
<body>
    
   <script>
    //    **代码形式为obj1 instanceof obj2（obj1是否是obj2的实例）**
    // obj2能否生成obj1,或者说是obj2.constructor有没有obj1.__proto__
    //{}.__proto__===Object.prototype   ,Array.prototype.__proto__
   console.log( {}.__proto__.__proto__,'{}.__proto__')//null 
   console.log(Object.prototype.__proto__,'Object.prototype.__proto__')//null
   console.log({},"{}.prototype.__proto__")
   //obj1 原型链上是否是Obj2.prototype.__proto
     console.log([] instanceof Object,"[] instanceof Object")//true
     console.log({} instanceof Object,{}.__proto__,'{} instanceof Object')//true
     console.log({} instanceof Array,'{} instanceof Array')//false
     //{}.__proto__   array.prototype
    //   function instanceoffn(A,B){//A.proptotype 是否存在于B 原型链上
    //      var L=A.__proto__  
    //      var R=B.prototype  
    //      if(L===R){
    //          return true
    //      }else{
    //          return false
    //      }
    //    }
    //  var arr1=[]
    //  var obj1={}
    //   console.log(instanceoffn({},[]),"{}是[]得实列吗：模拟")//{}.__proto__===[].prototype false 
    //   console.log(instanceoffn([],Object),"[]是Object得实列吗:模拟")//[].__proto__===Object.prototype
    //   console.log(instanceoffn([],Object),"[]是Object得实列吗:模拟")//[].__proto__===Object.prototype
    //   console.log([] instanceof Object,'[] instanceof Object,')//true 
    //   console.log({} instanceof Array,'{} instanceof Array,')//false =>{}.__proto__===Object
    //    var a = [34,4,3,54],
    //     b = 34,
    //     c = 'adsfas',
    //     d = function(){console.log('我是函数')},
    //     e = true,
    //     f = null,
    //     g;

    //     console.log(typeof(a));//object
    //     console.log(typeof(b));//number
    //     console.log(typeof(c));//string
    //     console.log(typeof(d));//function
    //     console.log(typeof(e));//boolean
    //     console.log(typeof(f));//object
    //     console.log(typeof(g));//undefined
    //     console.log(typeof([]),'[]')
    //     let s=Symbol()
    //     console.log(typeof(s),'symbol')
  
//        var fn=function(a){
//      console.log(a)//2
//  }(34)//如果将匿名函数放入到表达式中并且后面加上小括号会自动执行这个函数。

//        function fn(a,b){
//     console.log(a)
//     console.log(b)

//     var b=10
//     function a(){}
//     return 0
// }
// new fn(1,2)
// fn(1,2)
//        console.log(a,'a')
// console.log(b,'b')
// fn1()
// fn2()
// var a=1
// console.log(a,'aa')
// b=2
// function fn1(){
//     console.log(1)
// }
// var fn2=function(){
//     console.log(2)
// }
    //  console.log(a)//f a(){console.log(4)} 
    //  var a=1
    //  console.log(a)//1
    //  function a(){
    //      console.log(2)
    //  }
    //  console.log(a)//1
    //  var a=3
    //  console.log(a)//3
    //  function a(){
    //      console.log(4)
    //  }
    //  console.log(a)//3
    //  a()

// function outer(){ 
//     var inner = function(){
//         var obj = {};
//         obj.getVal=()=>{
//             console.log(this,'getVal');//f outer(){}  
//         }
//         console.log(this,'inner');//f outer(){}
//         return obj;
//     };
//     console.log(this,'outer');//window
//     return inner; 
// }
// var  aa=outer()()
// console.log(outer(),'aa')//f (){} inner闭包函数
// outer().bind(outer)().getVal();
 // 闭包函数的 inner 也是一个普通函数，仍然遵循 [谁调用，指向谁]，这里没有直接调用对象，而是最外层的“省略的” window 调用的，所以 inner 的 this 是指向 window 的。=》闭包


    //          var flag='996'
    //   function persons(fg){
    //       let o=new Object()
    //       o.flag=fg
    //       o.getval=()=>{
    //           console.log(this,'箭头函数里的this')//persons{a:1}
    //       }
    //       this.a=1
    //       console.log(this,'a后面的打印')//persons{a:1}
    //       return o
    //   }
    //   let pp=new persons('251')
    //   console.log(pp,'pp实列')//{flag: "251", getval: ƒ} 
    //   pp.getval()
//        var flag='996'
// function person(fg){//创建对象的方式是：工厂模式创建对象
//     let o=new Object()
//     o.flag=fg
//     o.getval=function(){
//         console.log(this,'getval')//{flag: "251", getval: ƒ} "getval"
//     }
//     console.log(this,'person')//person {} "person"
//     // console.log(this,'person') 在pp.getval()未调用之前就已经打印了
//     return o
// }
// let pp=new person('251');
// pp.getval()
      // 箭头函数 ：函数体内的this对象，就是定义时所在得对象，而不是使用时所在的对象
      //this对象得指向时可变的，但是在箭头函数中，它是固定得
    //   变量提升得问题 匿名函数 闭包 
    //1 箭头函数this 指向问题
    //    var flag='996'
    //    function persons(fg){
    //        let o=new Object()
    //        o.flag=fg
    //        console.log(this,'persons里的this')//this指向persons
    //        o.getval=()=>{
    //            console.log(this,'箭头函数里的this')//this指向persons
    //        }
    //        return o
    //    }
    //    let pp=new persons('251')
    //    console.log(pp,'pp实列')
    //    pp.getval()

    //2
    // 创建对象得几种方式，
    // var flag='996'
    //    function persons(fg){
    //        let o=new Object()//工厂模式创建对象
    //        o.flag=fg
    //        o.getval=()=>{
    //            console.log(this,'箭头函数里的this')//this指向persons
    //        }
    //        this.a=1
    //        console.log(this,'a后面的打印')
    //        return o
    //    }
    //    console.log(persons,'persons函数')
    //    let pp=new persons('251')
    //    console.log(pp,'pp实列')
    //    pp.getval()
    //3 o 返回为非对象的时候
    // var flag='996'
    //    function persons(fg){
    //        let o=true
    //        this.b=fg
    //        return o
    //    }
    //    let pp=new persons('251')
    //    console.log(pp,'pp实列')//返回persons:{b:'251'}

   </script> 
</body>
</html>